module CompileTraces

export CompilationMetrics, compile_traces

"""
Object used to track various metrics related to compilation successes and failures for later introspection.

For example, you might want to test or assert that all or at least a certain number of traces were successfully compiled.

Public fields:
- `succeeded`: the number of statements that successfully compiled.
- `failed`: the number of statements that failed to compile.
- `skipped`: the number of statements that were avoided due to limitations in compilation. This should be very rare, and related to overloaded `Vararg` or despecialized arguments.
- `total`: the number of statements that were processed. This is the sum of all three other fields.
"""
mutable struct CompilationMetrics
  succeeded::Int64
  failed::Int64
  skipped::Int64
  total::Int64
end

CompilationMetrics() = CompilationMetrics(0, 0, 0, 0)

function Base.show(io::IO, metrics::CompilationMetrics)
  print(io, CompilationMetrics, '(', "total: ", metrics.total, ", succeeded: ", metrics.succeeded, ", failed: ", metrics.failed, ", skipped: ", metrics.skipped, ')')
end

"""
    compile_traces(trace_files::AbstractString...; verbose=true, progress=true, warn=true)
    compile_traces(trace_files::AbstractVector{<:AbstractString}; verbose=true, progress=true, warn=true)

Execute precompile statements recorded in a trace file, returning a `CompilationMetrics` result.

The trace file will be expected to have been generated by the Julia command-line option `--trace-compile=<file>`. Specifically,
in the precompile directives, all names must be explicitly qualified with their parent module, e.g. `Base.ones` or `Main.f`.
For example, even if `ones` is exported from Base, `precompile(ones, Tuple{Int64})` will not work; `precompile(Tuple{typeof(Base.ones),Int64})`
will be correct.

Only the statements which are bound to known modules and types will be compiled. However, it is sufficient that top-level packages or modules are loaded in the session; if package A uses a type for B, B will already have been loaded with A, and so will be known to the session.

If generating a trace file from a script which includes types and functions defined in `Main`, it may be good practice to filter out traces which
contain `Main.`. This will remove a fair source of warnings.
"""
function compile_traces end

compile_traces(trace_files::AbstractString...; verbose=true, progress=true, warn=true) = compile_traces(collect(trace_files); verbose, progress, warn)

# Credits to PackageCompiler.jl for most of the following code.

function compile_traces(trace_files::AbstractVector{<:AbstractString}; verbose=true, progress=true, warn=true)
  metrics = CompilationMetrics()
  ex = quote
    metrics = $metrics
    using Base.Meta
    PrecompileStagingArea = Module()
    for (_pkgid, _mod) in Base.loaded_modules
      if !(_pkgid.name in ("Main", "Core", "Base"))
        try
          eval(PrecompileStagingArea, :(const $(Symbol(_mod)) = $_mod))
        catch
          str = sprint(showerror)
          # Skip redefinitions of modules corresponding to package extensions.
          # TODO: Investigate what is going on.
          contains(str, "Invalid redefinition of anonymous.") || rethrow()
        end
      end
    end
    statements = foldl((sts, file) -> append!(sts, eachline(file)), $trace_files; init=String[])
    $verbose && print("Executing precompile statements...")
    for statement in statements
      try
        # This is taken from https://github.com/JuliaLang/julia/blob/2c9e051c460dd9700e6814c8e49cc1f119ed8b41/contrib/generate_precompile.jl#L375-L393
        ps = Meta.parse(statement)
        if !isexpr(ps, :call)
          metrics.skipped += 1
          continue
        end
        popfirst!(ps.args) # precompile(...)
        ps.head = :tuple
        l = ps.args[end]
        if (isexpr(l, :tuple) || isexpr(l, :curly)) && length(l.args) > 0 # Tuple{...} or (...)
          # XXX: precompile doesn't currently handle overloaded Vararg arguments very well.
          # Replacing N with a large number works around it.
          l = l.args[end]
          if isexpr(l, :curly) && length(l.args) == 2 && l.args[1] === :Vararg # Vararg{T}
            push!(l.args, 100) # form Vararg{T, 100} instead
          end
        end
        ps = Core.eval(PrecompileStagingArea, ps)
        # XXX: precompile doesn't currently handle overloaded nospecialize arguments very well.
        # Skipping them avoids the warning.
        ms = length(ps) == 1 ? Base._methods_by_ftype(ps[1], 1, Base.get_world_counter()) : Base.methods(ps...)
        if !isa(ms, Vector)
          metrics.skipped += 1
          continue
        end
        precompile(ps...)
        metrics.succeeded += 1
        $progress || continue
        print("\rExecuting precompile statements... $(metrics.succeeded)/$(length(statements))")
        if !iszero(metrics.failed)
          print(" (failed: ")
          printstyled(metrics.failed; bold=true, color=:red)
          print(')')
        end
      catch e
        # See julia issue #28808
        e isa InterruptException && rethrow()
        metrics.failed += 1
        $warn || continue
        println()
        @warn "failed to execute $statement\n$(sprint(showerror, e))"
      end
    end
    if $verbose
      println()
      print("Successfully precompiled ")
      printstyled(metrics.succeeded; bold=true, color=:green)
      print(" statements")
      if !iszero(metrics.failed)
        print(" (")
        printstyled(metrics.failed; bold=true, color=:red)
        print(" failed)")
      end
      println()
    end
    metrics.total = metrics.succeeded + metrics.failed + metrics.skipped
  end

  Core.eval(Module(), ex)
  metrics
end

end
