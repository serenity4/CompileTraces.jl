module CompileTraces

export compile_traces

"""
    compile_traces(trace_files::AbstractString...; verbose=true, progress=true, warn=true)
    compile_traces(trace_files::AbstractVector{<:AbstractString}; verbose=true, progress=true, warn=true)

Execute precompile statements recorded in a trace file, compiling all methods which are bound to known modules and types.

The trace file will be expected to have been generated by the Julia command-line option `--trace-compile=<file>`. Specifically,
in the precompile directives, all names must be explicitly qualified with their parent module, e.g. `Base.ones` or `Main.f`.
For example, even if `ones` is exported from Base, `precompile(ones, Tuple{Int64})` will not work; `precompile(Tuple{typeof(Base.ones),Int64})`
will be correct.

It is sufficient that top-level packages or modules are loaded in the session; if package A uses a type for B, B will already
have been loaded with A, and so will be known to the session.

If generating a trace file from a script which includes types and functions defined in `Main`, it may be good practice to filter out traces which
contain `Main.`. This will remove a fair source of warnings.
"""
function compile_traces end

compile_traces(trace_files::AbstractString...; verbose=true, progress=true, warn=true) = compile_traces(collect(trace_files); verbose, progress, warn)

# Credits to PackageCompiler.jl for most of the following code.

function compile_traces(trace_files::AbstractVector{<:AbstractString}; verbose=true, progress=true, warn=true)
  ex = quote
    using Base.Meta
    PrecompileStagingArea = Module()
    for (_pkgid, _mod) in Base.loaded_modules
      if !(_pkgid.name in ("Main", "Core", "Base"))
        try
          eval(PrecompileStagingArea, :(const $(Symbol(_mod)) = $_mod))
        catch
          str = sprint(showerror)
          # Skip redefinitions of modules corresponding to package extensions.
          # TODO: Investigate what is going on.
          contains(str, "Invalid redefinition of anonymous.") || rethrow()
        end
      end
    end
    local n_succeeded = 0
    local n_failed = 0
    statements = foldl((sts, file) -> append!(sts, eachline(file)), $trace_files; init=String[])
    $verbose && print("Executing precompile statements...")
    for statement in statements
      try
        # This is taken from https://github.com/JuliaLang/julia/blob/2c9e051c460dd9700e6814c8e49cc1f119ed8b41/contrib/generate_precompile.jl#L375-L393
        ps = Meta.parse(statement)
        isexpr(ps, :call) || continue
        popfirst!(ps.args) # precompile(...)
        ps.head = :tuple
        l = ps.args[end]
        if (isexpr(l, :tuple) || isexpr(l, :curly)) && length(l.args) > 0 # Tuple{...} or (...)
          # XXX: precompile doesn't currently handle overloaded Vararg arguments very well.
          # Replacing N with a large number works around it.
          l = l.args[end]
          if isexpr(l, :curly) && length(l.args) == 2 && l.args[1] === :Vararg # Vararg{T}
            push!(l.args, 100) # form Vararg{T, 100} instead
          end
        end
        ps = Core.eval(PrecompileStagingArea, ps)
        # XXX: precompile doesn't currently handle overloaded nospecialize arguments very well.
        # Skipping them avoids the warning.
        ms = length(ps) == 1 ? Base._methods_by_ftype(ps[1], 1, Base.get_world_counter()) : Base.methods(ps...)
        ms isa Vector || continue
        precompile(ps...)
        n_succeeded += 1
        $progress || continue
        print("\rExecuting precompile statements... $n_succeeded/$(length(statements))")
        if !iszero(n_failed)
          print(" (failed: ")
          printstyled(n_failed; bold=true, color=:red)
          print(')')
        end
      catch e
        # See julia issue #28808
        e isa InterruptException && rethrow()
        n_failed += 1
        $warn || continue
        println()
        @warn "failed to execute $statement\n$(sprint(showerror, e))"
      end
    end
    if $verbose
      println()
      print("Successfully precompiled ")
      printstyled(n_succeeded; bold=true, color=:green)
      print(" statements")
      if !iszero(n_failed)
        print(" (")
        printstyled(n_failed; bold=true, color=:red)
        print(" failed)")
      end
      println()
    end
  end

  Core.eval(Module(), ex)
end

end
